{"ast":null,"code":"'use strict';\n\n// What key should we look at when composing?\nconst COMPOSE_SYMBOL = '~compose';\n\n/**\n * Returns a new error indicating circular sections.\n *\n * @param  {String} sectionName\n * The section at which the circularity was determined.\n *\n * @param  {String[]} path\n * The circular sections path.\n *\n * @return {Error} Our beautiful error.\n */\nfunction circularSectionsError(sectionName, path) {\n  const joinedPath = path.join(' -> ');\n  const message = `Circular sections! Path: ${joinedPath} -> [${sectionName}]`;\n  return new Error(message);\n}\n\n/**\n * Composes sections together recursively.\n *\n * Example declaration:\n *\n * ```yaml\n * web:\n *   DB_HOST: 'localhost'\n * auth:\n *   FB_CLIENT_ID: 123\n * development:\n *   compose: [web, auth]\n * tests:\n *   compose: development\n *   FB_CLIENT_ID: 456\n * ```\n *\n * @param  {Object} root\n * The root object containing sections.\n *\n * @param  {String[]} sectionsToCompose\n * Array of strings that map to sections in the root object.\n *\n * @return {Object}\n * A composed object.\n */\nmodule.exports = function composeSections(root, sectionsToCompose, state) {\n  if (!sectionsToCompose || sectionsToCompose.length === 0) return {};\n\n  // Passed along in the recursive call.\n  state = state || {\n    // Used for tracking circular sections.\n    sectionTracker: []\n  };\n  const composedObject = {};\n  const sections = sectionsToCompose.concat([]);\n\n  // So imperative.. If you can make this \"Functional As Fuck™\",\n  // please make a PR. :)\n  while (sections.length > 0) {\n    const sectionName = sections[0];\n    if (state.sectionTracker.indexOf(sectionName) > -1) {\n      throw circularSectionsError(sectionName, state.sectionTracker);\n    }\n    const section = root[sectionName];\n    state.sectionTracker.push(sectionName);\n    if (section) {\n      Object.assign(composedObject, composeSections(root, [].concat(section[COMPOSE_SYMBOL] || []), state), section);\n      delete composedObject[COMPOSE_SYMBOL];\n    }\n    state.sectionTracker.pop();\n    sections.shift();\n  }\n  return composedObject;\n};","map":{"version":3,"names":["COMPOSE_SYMBOL","circularSectionsError","sectionName","path","joinedPath","join","message","Error","module","exports","composeSections","root","sectionsToCompose","state","length","sectionTracker","composedObject","sections","concat","indexOf","section","push","Object","assign","pop","shift"],"sources":["/home/roncalloj/Codes/new_project_react/frontend/node_modules/yenv/lib/composeSections.js"],"sourcesContent":["'use strict'\n\n// What key should we look at when composing?\nconst COMPOSE_SYMBOL = '~compose'\n\n/**\n * Returns a new error indicating circular sections.\n *\n * @param  {String} sectionName\n * The section at which the circularity was determined.\n *\n * @param  {String[]} path\n * The circular sections path.\n *\n * @return {Error} Our beautiful error.\n */\nfunction circularSectionsError(sectionName, path) {\n  const joinedPath = path.join(' -> ')\n  const message = `Circular sections! Path: ${joinedPath} -> [${sectionName}]`\n  return new Error(message)\n}\n\n/**\n * Composes sections together recursively.\n *\n * Example declaration:\n *\n * ```yaml\n * web:\n *   DB_HOST: 'localhost'\n * auth:\n *   FB_CLIENT_ID: 123\n * development:\n *   compose: [web, auth]\n * tests:\n *   compose: development\n *   FB_CLIENT_ID: 456\n * ```\n *\n * @param  {Object} root\n * The root object containing sections.\n *\n * @param  {String[]} sectionsToCompose\n * Array of strings that map to sections in the root object.\n *\n * @return {Object}\n * A composed object.\n */\nmodule.exports = function composeSections(root, sectionsToCompose, state) {\n  if (!sectionsToCompose || sectionsToCompose.length === 0) return {}\n\n  // Passed along in the recursive call.\n  state = state || {\n    // Used for tracking circular sections.\n    sectionTracker: [],\n  }\n\n  const composedObject = {}\n  const sections = sectionsToCompose.concat([])\n\n  // So imperative.. If you can make this \"Functional As Fuck™\",\n  // please make a PR. :)\n  while (sections.length > 0) {\n    const sectionName = sections[0]\n    if (state.sectionTracker.indexOf(sectionName) > -1) {\n      throw circularSectionsError(sectionName, state.sectionTracker)\n    }\n\n    const section = root[sectionName]\n    state.sectionTracker.push(sectionName)\n    if (section) {\n      Object.assign(\n        composedObject,\n        composeSections(root, [].concat(section[COMPOSE_SYMBOL] || []), state),\n        section\n      )\n      delete composedObject[COMPOSE_SYMBOL]\n    }\n\n    state.sectionTracker.pop()\n    sections.shift()\n  }\n\n  return composedObject\n}\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA,MAAMA,cAAc,GAAG,UAAU;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,qBAAqBA,CAACC,WAAW,EAAEC,IAAI,EAAE;EAChD,MAAMC,UAAU,GAAGD,IAAI,CAACE,IAAI,CAAC,MAAM,CAAC;EACpC,MAAMC,OAAO,GAAI,4BAA2BF,UAAW,QAAOF,WAAY,GAAE;EAC5E,OAAO,IAAIK,KAAK,CAACD,OAAO,CAAC;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAE,MAAM,CAACC,OAAO,GAAG,SAASC,eAAeA,CAACC,IAAI,EAAEC,iBAAiB,EAAEC,KAAK,EAAE;EACxE,IAAI,CAACD,iBAAiB,IAAIA,iBAAiB,CAACE,MAAM,KAAK,CAAC,EAAE,OAAO,CAAC,CAAC;;EAEnE;EACAD,KAAK,GAAGA,KAAK,IAAI;IACf;IACAE,cAAc,EAAE;EAClB,CAAC;EAED,MAAMC,cAAc,GAAG,CAAC,CAAC;EACzB,MAAMC,QAAQ,GAAGL,iBAAiB,CAACM,MAAM,CAAC,EAAE,CAAC;;EAE7C;EACA;EACA,OAAOD,QAAQ,CAACH,MAAM,GAAG,CAAC,EAAE;IAC1B,MAAMZ,WAAW,GAAGe,QAAQ,CAAC,CAAC,CAAC;IAC/B,IAAIJ,KAAK,CAACE,cAAc,CAACI,OAAO,CAACjB,WAAW,CAAC,GAAG,CAAC,CAAC,EAAE;MAClD,MAAMD,qBAAqB,CAACC,WAAW,EAAEW,KAAK,CAACE,cAAc,CAAC;IAChE;IAEA,MAAMK,OAAO,GAAGT,IAAI,CAACT,WAAW,CAAC;IACjCW,KAAK,CAACE,cAAc,CAACM,IAAI,CAACnB,WAAW,CAAC;IACtC,IAAIkB,OAAO,EAAE;MACXE,MAAM,CAACC,MAAM,CACXP,cAAc,EACdN,eAAe,CAACC,IAAI,EAAE,EAAE,CAACO,MAAM,CAACE,OAAO,CAACpB,cAAc,CAAC,IAAI,EAAE,CAAC,EAAEa,KAAK,CAAC,EACtEO,OACF,CAAC;MACD,OAAOJ,cAAc,CAAChB,cAAc,CAAC;IACvC;IAEAa,KAAK,CAACE,cAAc,CAACS,GAAG,CAAC,CAAC;IAC1BP,QAAQ,CAACQ,KAAK,CAAC,CAAC;EAClB;EAEA,OAAOT,cAAc;AACvB,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}