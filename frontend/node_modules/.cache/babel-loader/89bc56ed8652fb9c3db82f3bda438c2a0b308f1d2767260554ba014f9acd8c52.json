{"ast":null,"code":"'use strict';\n\nconst path = require('path');\nconst merge = require('deep-extend');\nconst loadAndParse = require('./loadAndParse');\n\n// Import symbol key.\nconst IMPORT_SYMBOL = '~import';\n// Require symbol key\nconst REQUIRE_SYMBOL = '~require';\n\n/**\n * Constructs a circular imports error.\n *\n * @param  {string} fileBeingImported\n * The file being imported.\n *\n * @param  {string} importingFile\n * The file that imported.\n *\n * @return {Error}\n * An error.\n */\nfunction circularImportsError(fileBeingImported, importTrail) {\n  const message = `Circular import of \"${fileBeingImported}\".\\r\\n` + 'Import trace:\\r\\n' + importTrail.map(f => ` -> ${f}`).join('\\r\\n');\n  return new Error(message);\n}\n\n/**\n * Processes import statements.\n *\n * @param  {object} obj\n * The object to process imports on.\n *\n * @param  {object} opts\n * Options.\n *\n * @param {string} opts.importingFile\n * Required! Used to base import cwd's.\n *\n * @return {object}\n * The merged sections\n */\nmodule.exports = function processImports(parsed, opts, state) {\n  // Since this function is recursive, we pass state along\n  state = state || {\n    importTrail: [],\n    loadedFiles: []\n  };\n  state.loadedFiles.push(opts.importingFile);\n  state.importTrail.unshift(opts.importingFile);\n\n  // Helper to check if we have already loaded the given file.\n  const hasLoadedFile = f => state.loadedFiles.indexOf(f) > -1;\n\n  // We need to reverse the order to get the last imported file to win over earlier\n  // imported files. This is because the outer file is merged onto the inner one,\n  // so if we did not reverse then the first imported file would win.\n  const files = [...mapFiles(parsed[IMPORT_SYMBOL], opts.importingFile, false), ...mapFiles(parsed[REQUIRE_SYMBOL], opts.importingFile, true)].reverse();\n  delete parsed[IMPORT_SYMBOL];\n  delete parsed[REQUIRE_SYMBOL];\n  return files.reduce((processed, descriptor) => {\n    if (hasLoadedFile(descriptor.file)) {\n      throw circularImportsError(descriptor.file, state.importTrail);\n    }\n    const loaded = loadAndParse(descriptor.file, !descriptor.required);\n    const loadedAndProcessed = processImports(loaded, Object.assign({}, opts, {\n      importingFile: descriptor.file\n    }), Object.assign({}, state, {\n      importTrail: [...state.importTrail]\n    }));\n\n    // Make sure all top-level nodes are not null (empty sections)\n    Object.keys(processed).forEach(key => {\n      const value = processed[key];\n      if (value === null) {\n        processed[key] = {};\n      }\n    });\n    return merge(loadedAndProcessed, processed);\n  }, parsed);\n};\n\n/**\n * Maps file paths as well as whether not they are required to descriptors.\n */\nfunction mapFiles(files, relative, required) {\n  if (!files) {\n    return [];\n  }\n  if (Array.isArray(files) === false) {\n    files = [files];\n  }\n  return files.map(f => ({\n    file: resolvePath(relative, f),\n    required: required\n  }));\n}\n\n/**\n * Resolves a path relative to another.\n */\nfunction resolvePath(relative, file) {\n  return path.resolve(path.dirname(relative), file);\n}","map":{"version":3,"names":["path","require","merge","loadAndParse","IMPORT_SYMBOL","REQUIRE_SYMBOL","circularImportsError","fileBeingImported","importTrail","message","map","f","join","Error","module","exports","processImports","parsed","opts","state","loadedFiles","push","importingFile","unshift","hasLoadedFile","indexOf","files","mapFiles","reverse","reduce","processed","descriptor","file","loaded","required","loadedAndProcessed","Object","assign","keys","forEach","key","value","relative","Array","isArray","resolvePath","resolve","dirname"],"sources":["/home/roncalloj/Codes/new_project_react/node_modules/yenv/lib/processImports.js"],"sourcesContent":["'use strict'\n\nconst path = require('path')\nconst merge = require('deep-extend')\n\nconst loadAndParse = require('./loadAndParse')\n\n// Import symbol key.\nconst IMPORT_SYMBOL = '~import'\n// Require symbol key\nconst REQUIRE_SYMBOL = '~require'\n\n/**\n * Constructs a circular imports error.\n *\n * @param  {string} fileBeingImported\n * The file being imported.\n *\n * @param  {string} importingFile\n * The file that imported.\n *\n * @return {Error}\n * An error.\n */\nfunction circularImportsError(fileBeingImported, importTrail) {\n  const message =\n    `Circular import of \"${fileBeingImported}\".\\r\\n` +\n    'Import trace:\\r\\n' +\n    importTrail.map((f) => ` -> ${f}`).join('\\r\\n')\n  return new Error(message)\n}\n\n/**\n * Processes import statements.\n *\n * @param  {object} obj\n * The object to process imports on.\n *\n * @param  {object} opts\n * Options.\n *\n * @param {string} opts.importingFile\n * Required! Used to base import cwd's.\n *\n * @return {object}\n * The merged sections\n */\nmodule.exports = function processImports(parsed, opts, state) {\n  // Since this function is recursive, we pass state along\n  state = state || {\n    importTrail: [],\n    loadedFiles: [],\n  }\n\n  state.loadedFiles.push(opts.importingFile)\n  state.importTrail.unshift(opts.importingFile)\n\n  // Helper to check if we have already loaded the given file.\n  const hasLoadedFile = (f) => state.loadedFiles.indexOf(f) > -1\n\n  // We need to reverse the order to get the last imported file to win over earlier\n  // imported files. This is because the outer file is merged onto the inner one,\n  // so if we did not reverse then the first imported file would win.\n  const files = [\n    ...mapFiles(parsed[IMPORT_SYMBOL], opts.importingFile, false),\n    ...mapFiles(parsed[REQUIRE_SYMBOL], opts.importingFile, true),\n  ].reverse()\n  delete parsed[IMPORT_SYMBOL]\n  delete parsed[REQUIRE_SYMBOL]\n  return files.reduce((processed, descriptor) => {\n    if (hasLoadedFile(descriptor.file)) {\n      throw circularImportsError(descriptor.file, state.importTrail)\n    }\n    const loaded = loadAndParse(descriptor.file, !descriptor.required)\n    const loadedAndProcessed = processImports(\n      loaded,\n      Object.assign({}, opts, { importingFile: descriptor.file }),\n      Object.assign({}, state, {\n        importTrail: [...state.importTrail],\n      })\n    )\n\n    // Make sure all top-level nodes are not null (empty sections)\n    Object.keys(processed).forEach((key) => {\n      const value = processed[key]\n      if (value === null) {\n        processed[key] = {}\n      }\n    })\n\n    return merge(loadedAndProcessed, processed)\n  }, parsed)\n}\n\n/**\n * Maps file paths as well as whether not they are required to descriptors.\n */\nfunction mapFiles(files, relative, required) {\n  if (!files) {\n    return []\n  }\n\n  if (Array.isArray(files) === false) {\n    files = [files]\n  }\n\n  return files.map((f) => ({\n    file: resolvePath(relative, f),\n    required: required,\n  }))\n}\n\n/**\n * Resolves a path relative to another.\n */\nfunction resolvePath(relative, file) {\n  return path.resolve(path.dirname(relative), file)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}